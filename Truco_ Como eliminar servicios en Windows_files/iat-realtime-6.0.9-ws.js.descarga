!function r(n,s,i){function a(t,e){if(!s[t]){if(!n[t]){var o="function"==typeof require&&require;if(!e&&o)return o(t,!0);if(c)return c(t,!0);throw(e=new Error("Cannot find module '"+t+"'")).code="MODULE_NOT_FOUND",e}o=s[t]={exports:{}},n[t][0].call(o.exports,function(e){return a(n[t][1][e]||e)},o,o.exports,r,n,s,i)}return s[t].exports}for(var c="function"==typeof require&&require,e=0;e<i.length;e++)a(i[e]);return a}({1:[function(e,t,o){"use strict";Object.defineProperty(o,"__esModule",{value:!0}),o.AbortController=void 0;o.AbortController=class{constructor(){this._isAborted=!1,this.onabort=null}abort(){this._isAborted||(this._isAborted=!0,this.onabort&&this.onabort())}get signal(){return this}get aborted(){return this._isAborted}}},{}],2:[function(e,t,o){"use strict";Object.defineProperty(o,"__esModule",{value:!0}),o.DefaultHttpClient=void 0;const r=e("./Errors"),n=e("./FetchHttpClient");var s=e("./HttpClient");const i=e("./Utils"),a=e("./XhrHttpClient");class c extends s.HttpClient{constructor(e){if(super(),"undefined"!=typeof fetch||i.Platform.isNode)this._httpClient=new n.FetchHttpClient(e);else{if("undefined"==typeof XMLHttpRequest)throw new Error("No usable HttpClient found.");this._httpClient=new a.XhrHttpClient(e)}}send(e){return e.abortSignal&&e.abortSignal.aborted?Promise.reject(new r.AbortError):e.method?e.url?this._httpClient.send(e):Promise.reject(new Error("No url defined.")):Promise.reject(new Error("No method defined."))}getCookieString(e){return this._httpClient.getCookieString(e)}}o.DefaultHttpClient=c},{"./Errors":4,"./FetchHttpClient":5,"./HttpClient":8,"./Utils":21,"./XhrHttpClient":23}],3:[function(e,t,o){"use strict";Object.defineProperty(o,"__esModule",{value:!0}),o.DefaultReconnectPolicy=void 0;const r=[0,2e3,1e4,3e4,null];o.DefaultReconnectPolicy=class{constructor(e){this._retryDelays=void 0!==e?[...e,null]:r}nextRetryDelayInMilliseconds(e){return this._retryDelays[e.previousRetryCount]}}},{}],4:[function(e,t,o){"use strict";Object.defineProperty(o,"__esModule",{value:!0}),o.AggregateErrors=o.FailedToNegotiateWithServerError=o.FailedToStartTransportError=o.DisabledTransportError=o.UnsupportedTransportError=o.AbortError=o.TimeoutError=o.HttpError=void 0;class r extends Error{constructor(e,t){var o=new.target.prototype;super(e+`: Status code '${t}'`),this.statusCode=t,this.__proto__=o}}o.HttpError=r;class n extends Error{constructor(e="A timeout occurred."){var t=new.target.prototype;super(e),this.__proto__=t}}o.TimeoutError=n;class s extends Error{constructor(e="An abort occurred."){var t=new.target.prototype;super(e),this.__proto__=t}}o.AbortError=s;class i extends Error{constructor(e,t){var o=new.target.prototype;super(e),this.transport=t,this.errorType="UnsupportedTransportError",this.__proto__=o}}o.UnsupportedTransportError=i;class a extends Error{constructor(e,t){var o=new.target.prototype;super(e),this.transport=t,this.errorType="DisabledTransportError",this.__proto__=o}}o.DisabledTransportError=a;class c extends Error{constructor(e,t){var o=new.target.prototype;super(e),this.transport=t,this.errorType="FailedToStartTransportError",this.__proto__=o}}o.FailedToStartTransportError=c;class l extends Error{constructor(e){var t=new.target.prototype;super(e),this.errorType="FailedToNegotiateWithServerError",this.__proto__=t}}o.FailedToNegotiateWithServerError=l;class h extends Error{constructor(e,t){var o=new.target.prototype;super(e),this.innerErrors=t,this.__proto__=o}}o.AggregateErrors=h},{}],5:[function(r,e,t){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.FetchHttpClient=void 0;const i=r("./Errors"),a=r("./HttpClient"),c=r("./ILogger"),n=r("./Utils");class o extends a.HttpClient{constructor(e){if(super(),this._logger=e,"undefined"==typeof fetch){const t="function"==typeof __webpack_require__?__non_webpack_require__:r;this._jar=new(t("tough-cookie").CookieJar),this._fetchType=t("node-fetch"),this._fetchType=t("fetch-cookie")(this._fetchType,this._jar)}else this._fetchType=fetch.bind(n.getGlobalThis());if("undefined"==typeof AbortController){const o="function"==typeof __webpack_require__?__non_webpack_require__:r;this._abortControllerType=o("abort-controller")}else this._abortControllerType=AbortController}async send(e){if(e.abortSignal&&e.abortSignal.aborted)throw new i.AbortError;if(!e.method)throw new Error("No method defined.");if(!e.url)throw new Error("No url defined.");const t=new this._abortControllerType;let o,r=(e.abortSignal&&(e.abortSignal.onabort=()=>{t.abort(),o=new i.AbortError}),null);var n;e.timeout&&(n=e.timeout,r=setTimeout(()=>{t.abort(),this._logger.log(c.LogLevel.Warning,"Timeout from HTTP request."),o=new i.TimeoutError},n));let s;try{s=await this._fetchType(e.url,{body:e.content,cache:"no-cache",credentials:!0===e.withCredentials?"include":"same-origin",headers:{"Content-Type":"text/plain;charset=UTF-8","X-Requested-With":"XMLHttpRequest",...e.headers},method:e.method,mode:"cors",redirect:"follow",signal:t.signal})}catch(e){if(o)throw o;throw this._logger.log(c.LogLevel.Warning,`Error from HTTP request. ${e}.`),e}finally{r&&clearTimeout(r),e.abortSignal&&(e.abortSignal.onabort=null)}if(s.ok)return n=await l(s,e.responseType),new a.HttpResponse(s.status,s.statusText,n);throw e=await l(s,"text"),new i.HttpError(e||s.statusText,s.status)}getCookieString(e){let o="";return n.Platform.isNode&&this._jar&&this._jar.getCookies(e,(e,t)=>o=t.join("; ")),o}}function l(e,t){let o;switch(t){case"arraybuffer":o=e.arrayBuffer();break;case"text":o=e.text();break;case"blob":case"document":case"json":throw new Error(t+" is not supported.");default:o=e.text()}return o}t.FetchHttpClient=o},{"./Errors":4,"./HttpClient":8,"./ILogger":13,"./Utils":21}],6:[function(e,t,o){"use strict";Object.defineProperty(o,"__esModule",{value:!0}),o.HandshakeProtocol=void 0;const i=e("./TextMessageFormat"),a=e("./Utils");o.HandshakeProtocol=class{writeHandshakeRequest(e){return i.TextMessageFormat.write(JSON.stringify(e))}parseHandshakeResponse(e){let t,o;if(a.isArrayBuffer(e)){const n=new Uint8Array(e);var r=n.indexOf(i.TextMessageFormat.RecordSeparatorCode);if(-1===r)throw new Error("Message is incomplete.");r=r+1;t=String.fromCharCode.apply(null,Array.prototype.slice.call(n.slice(0,r))),o=n.byteLength>r?n.slice(r).buffer:null}else{const s=e;r=s.indexOf(i.TextMessageFormat.RecordSeparator);if(-1===r)throw new Error("Message is incomplete.");e=r+1;t=s.substring(0,e),o=s.length>e?s.substring(e):null}r=i.TextMessageFormat.parse(t),e=JSON.parse(r[0]);if(e.type)throw new Error("Expected a handshake response from the server.");return[o,e]}}},{"./TextMessageFormat":20,"./Utils":21}],7:[function(e,t,o){"use strict";Object.defineProperty(o,"__esModule",{value:!0}),o.HeaderNames=void 0;class r{}(o.HeaderNames=r).Authorization="Authorization",r.Cookie="Cookie"},{}],8:[function(e,t,o){"use strict";Object.defineProperty(o,"__esModule",{value:!0}),o.HttpClient=o.HttpResponse=void 0;o.HttpResponse=class{constructor(e,t,o){this.statusCode=e,this.statusText=t,this.content=o}};o.HttpClient=class{get(e,t){return this.send({...t,method:"GET",url:e})}post(e,t){return this.send({...t,method:"POST",url:e})}delete(e,t){return this.send({...t,method:"DELETE",url:e})}getCookieString(e){return""}}},{}],9:[function(s,e,t){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.TransportSendQueue=t.HttpConnection=void 0;const i=s("./DefaultHttpClient"),l=s("./Errors"),a=s("./HeaderNames"),h=s("./ILogger"),g=s("./ITransport"),c=s("./LongPollingTransport"),o=s("./ServerSentEventsTransport"),u=s("./Utils"),r=s("./WebSocketTransport");t.HttpConnection=class{constructor(e,t={}){if(this._stopPromiseResolver=()=>{},this.features={},this._negotiateVersion=1,u.Arg.isRequired(e,"url"),this._logger=u.createLogger(t.logger),this.baseUrl=this._resolveUrl(e),(t=t||{}).logMessageContent=void 0!==t.logMessageContent&&t.logMessageContent,"boolean"!=typeof t.withCredentials&&void 0!==t.withCredentials)throw new Error("withCredentials option was not a 'boolean' or 'undefined' value");t.withCredentials=void 0===t.withCredentials||t.withCredentials,t.timeout=void 0===t.timeout?1e5:t.timeout;let o=null,r=null;if(u.Platform.isNode&&void 0!==s){const n="function"==typeof __webpack_require__?__non_webpack_require__:s;o=n("ws"),r=n("eventsource")}u.Platform.isNode||"undefined"==typeof WebSocket||t.WebSocket?u.Platform.isNode&&!t.WebSocket&&o&&(t.WebSocket=o):t.WebSocket=WebSocket,u.Platform.isNode||"undefined"==typeof EventSource||t.EventSource?u.Platform.isNode&&!t.EventSource&&void 0!==r&&(t.EventSource=r):t.EventSource=EventSource,this._httpClient=t.httpClient||new i.DefaultHttpClient(this._logger),this._connectionState="Disconnected",this._connectionStarted=!1,this._options=t,this.onreceive=null,this.onclose=null}async start(e){return e=e||g.TransferFormat.Binary,u.Arg.isIn(e,g.TransferFormat,"transferFormat"),this._logger.log(h.LogLevel.Debug,`Starting connection with transfer format '${g.TransferFormat[e]}'.`),"Disconnected"!==this._connectionState?Promise.reject(new Error("Cannot start an HttpConnection that is not in the 'Disconnected' state.")):(this._connectionState="Connecting",this._startInternalPromise=this._startInternal(e),await this._startInternalPromise,"Disconnecting"===this._connectionState?(e="Failed to start the HttpConnection before stop() was called.",this._logger.log(h.LogLevel.Error,e),await this._stopPromise,Promise.reject(new Error(e))):"Connected"!==this._connectionState?(e="HttpConnection.startInternal completed gracefully but didn't enter the connection into the connected state!",this._logger.log(h.LogLevel.Error,e),Promise.reject(new Error(e))):void(this._connectionStarted=!0))}send(e){return"Connected"!==this._connectionState?Promise.reject(new Error("Cannot send data if the connection is not in the 'Connected' State.")):(this._sendQueue||(this._sendQueue=new n(this.transport)),this._sendQueue.send(e))}async stop(e){return"Disconnected"===this._connectionState?(this._logger.log(h.LogLevel.Debug,`Call to HttpConnection.stop(${e}) ignored because the connection is already in the disconnected state.`),Promise.resolve()):"Disconnecting"===this._connectionState?(this._logger.log(h.LogLevel.Debug,`Call to HttpConnection.stop(${e}) ignored because the connection is already in the disconnecting state.`),this._stopPromise):(this._connectionState="Disconnecting",this._stopPromise=new Promise(e=>{this._stopPromiseResolver=e}),await this._stopInternal(e),void await this._stopPromise)}async _stopInternal(e){this._stopError=e;try{await this._startInternalPromise}catch(e){}if(this.transport){try{await this.transport.stop()}catch(e){this._logger.log(h.LogLevel.Error,`HttpConnection.transport.stop() threw error '${e}'.`),this._stopConnection()}this.transport=void 0}else this._logger.log(h.LogLevel.Debug,"HttpConnection.transport is undefined in HttpConnection.stop() because start() failed.")}async _startInternal(o){let r=this.baseUrl;this._accessTokenFactory=this._options.accessTokenFactory;try{if(this._options.skipNegotiation){if(this._options.transport!==g.HttpTransportType.WebSockets)throw new Error("Negotiation can only be skipped when using the WebSocket transport directly.");this.transport=this._constructTransport(g.HttpTransportType.WebSockets),await this._startTransport(r,o)}else{let e=null,t=0;do{if(e=await this._getNegotiationResponse(r),"Disconnecting"===this._connectionState||"Disconnected"===this._connectionState)throw new Error("The connection was stopped during negotiation.");if(e.error)throw new Error(e.error);if(e.ProtocolVersion)throw new Error("Detected a connection attempt to an ASP.NET SignalR Server. This client only supports connecting to an ASP.NET Core SignalR Server. See https://aka.ms/signalr-core-differences for details.");if(e.url&&(r=e.url),e.accessToken){const n=e.accessToken;this._accessTokenFactory=()=>n}}while(t++,e.url&&t<100);if(100===t&&e.url)throw new Error("Negotiate redirection limit exceeded.");await this._createTransport(r,this._options.transport,e,o)}this.transport instanceof c.LongPollingTransport&&(this.features.inherentKeepAlive=!0),"Connecting"===this._connectionState&&(this._logger.log(h.LogLevel.Debug,"The HttpConnection connected successfully."),this._connectionState="Connected")}catch(e){return this._logger.log(h.LogLevel.Error,"Failed to start the connection: "+e),this._connectionState="Disconnected",this.transport=void 0,this._stopPromiseResolver(),Promise.reject(e)}}async _getNegotiationResponse(e){const t={};this._accessTokenFactory&&(o=await this._accessTokenFactory())&&(t[a.HeaderNames.Authorization]="Bearer "+o);var[o,r]=u.getUserAgentHeader(),o=(t[o]=r,this._resolveNegotiateUrl(e));this._logger.log(h.LogLevel.Debug,`Sending negotiation request: ${o}.`);try{var n=await this._httpClient.post(o,{content:"",headers:{...t,...this._options.headers},timeout:this._options.timeout,withCredentials:this._options.withCredentials});if(200!==n.statusCode)return Promise.reject(new Error(`Unexpected status code returned from negotiate '${n.statusCode}'`));const s=JSON.parse(n.content);return(!s.negotiateVersion||s.negotiateVersion<1)&&(s.connectionToken=s.connectionId),s}catch(e){let t="Failed to complete negotiation with the server: "+e;return e instanceof l.HttpError&&404===e.statusCode&&(t+=" Either this is not a SignalR endpoint or there is a proxy blocking the connection."),this._logger.log(h.LogLevel.Error,t),Promise.reject(new l.FailedToNegotiateWithServerError(t))}}_createConnectUrl(e,t){return t?e+(-1===e.indexOf("?")?"?":"&")+"id="+t:e}async _createTransport(e,o,r,n){let s=this._createConnectUrl(e,r.connectionToken);if(!this._isITransport(o)){const a=[];let t=r;for(const c of r.availableTransports||[]){var i=this._resolveTransportOrError(c,o,n);if(i instanceof Error)a.push(c.transport+" failed:"),a.push(i);else if(this._isITransport(i)){if(this.transport=i,!t){try{t=await this._getNegotiationResponse(e)}catch(e){return Promise.reject(e)}s=this._createConnectUrl(e,t.connectionToken)}try{return await this._startTransport(s,n),void(this.connectionId=t.connectionId)}catch(e){if(this._logger.log(h.LogLevel.Error,`Failed to start the transport '${c.transport}': `+e),t=void 0,a.push(new l.FailedToStartTransportError(c.transport+" failed: "+e,g.HttpTransportType[c.transport])),"Connecting"!==this._connectionState)return i="Failed to select transport before stop() was called.",this._logger.log(h.LogLevel.Debug,i),Promise.reject(new Error(i))}}}return 0<a.length?Promise.reject(new l.AggregateErrors("Unable to connect to the server with any of the available transports. "+a.join(" "),a)):Promise.reject(new Error("None of the transports supported by the client are supported by the server."))}this._logger.log(h.LogLevel.Debug,"Connection was provided an instance of ITransport, using that directly."),this.transport=o,await this._startTransport(s,n),this.connectionId=r.connectionId}_constructTransport(e){switch(e){case g.HttpTransportType.WebSockets:if(this._options.WebSocket)return new r.WebSocketTransport(this._httpClient,this._accessTokenFactory,this._logger,this._options.logMessageContent,this._options.WebSocket,this._options.headers||{});throw new Error("'WebSocket' is not supported in your environment.");case g.HttpTransportType.ServerSentEvents:if(this._options.EventSource)return new o.ServerSentEventsTransport(this._httpClient,this._accessTokenFactory,this._logger,this._options);throw new Error("'EventSource' is not supported in your environment.");case g.HttpTransportType.LongPolling:return new c.LongPollingTransport(this._httpClient,this._accessTokenFactory,this._logger,this._options);default:throw new Error(`Unknown transport: ${e}.`)}}_startTransport(e,t){return this.transport.onreceive=this.onreceive,this.transport.onclose=e=>this._stopConnection(e),this.transport.connect(e,t)}_resolveTransportOrError(e,t,o){var r,n=g.HttpTransportType[e.transport];if(null==n)return this._logger.log(h.LogLevel.Debug,`Skipping transport '${e.transport}' because it is not supported by this client.`),new Error(`Skipping transport '${e.transport}' because it is not supported by this client.`);if(r=n,(t=t)&&0==(r&t))return this._logger.log(h.LogLevel.Debug,`Skipping transport '${g.HttpTransportType[n]}' because it was disabled by the client.`),new l.DisabledTransportError(`'${g.HttpTransportType[n]}' is disabled by the client.`,n);{const s=e.transferFormats.map(e=>g.TransferFormat[e]);if(!(0<=s.indexOf(o)))return this._logger.log(h.LogLevel.Debug,`Skipping transport '${g.HttpTransportType[n]}' because it does not support the requested transfer format '${g.TransferFormat[o]}'.`),new Error(`'${g.HttpTransportType[n]}' does not support ${g.TransferFormat[o]}.`);if(n===g.HttpTransportType.WebSockets&&!this._options.WebSocket||n===g.HttpTransportType.ServerSentEvents&&!this._options.EventSource)return this._logger.log(h.LogLevel.Debug,`Skipping transport '${g.HttpTransportType[n]}' because it is not supported in your environment.'`),new l.UnsupportedTransportError(`'${g.HttpTransportType[n]}' is not supported in your environment.`,n);this._logger.log(h.LogLevel.Debug,`Selecting transport '${g.HttpTransportType[n]}'.`);try{return this._constructTransport(n)}catch(e){return e}}}_isITransport(e){return e&&"object"==typeof e&&"connect"in e}_stopConnection(t){if(this._logger.log(h.LogLevel.Debug,`HttpConnection.stopConnection(${t}) called while in state ${this._connectionState}.`),this.transport=void 0,t=this._stopError||t,this._stopError=void 0,"Disconnected"===this._connectionState)this._logger.log(h.LogLevel.Debug,`Call to HttpConnection.stopConnection(${t}) was ignored because the connection is already in the disconnected state.`);else{if("Connecting"===this._connectionState)throw this._logger.log(h.LogLevel.Warning,`Call to HttpConnection.stopConnection(${t}) was ignored because the connection is still in the connecting state.`),new Error(`HttpConnection.stopConnection(${t}) was called while the connection is still in the connecting state.`);if("Disconnecting"===this._connectionState&&this._stopPromiseResolver(),t?this._logger.log(h.LogLevel.Error,`Connection disconnected with error '${t}'.`):this._logger.log(h.LogLevel.Information,"Connection disconnected."),this._sendQueue&&(this._sendQueue.stop().catch(e=>{this._logger.log(h.LogLevel.Error,`TransportSendQueue.stop() threw error '${e}'.`)}),this._sendQueue=void 0),this.connectionId=void 0,this._connectionState="Disconnected",this._connectionStarted){this._connectionStarted=!1;try{this.onclose&&this.onclose(t)}catch(e){this._logger.log(h.LogLevel.Error,`HttpConnection.onclose(${t}) threw error '${e}'.`)}}}}_resolveUrl(e){if(0===e.lastIndexOf("https://",0)||0===e.lastIndexOf("http://",0))return e;if(!u.Platform.isBrowser)throw new Error(`Cannot resolve '${e}'.`);const t=window.document.createElement("a");return t.href=e,this._logger.log(h.LogLevel.Information,`Normalizing '${e}' to '${t.href}'.`),t.href}_resolveNegotiateUrl(e){var t=e.indexOf("?");let o=e.substring(0,-1===t?e.length:t);return"/"!==o[o.length-1]&&(o+="/"),o=-1===(o=(o+="negotiate")+(-1===t?"":e.substring(t))).indexOf("negotiateVersion")?(o+=-1===t?"?":"&")+"negotiateVersion="+this._negotiateVersion:o}};class n{constructor(e){this._transport=e,this._buffer=[],this._executing=!0,this._sendBufferedData=new p,this._transportResult=new p,this._sendLoopPromise=this._sendLoop()}send(e){return this._bufferData(e),this._transportResult||(this._transportResult=new p),this._transportResult.promise}stop(){return this._executing=!1,this._sendBufferedData.resolve(),this._sendLoopPromise}_bufferData(e){if(this._buffer.length&&typeof this._buffer[0]!=typeof e)throw new Error(`Expected data to be of type ${typeof this._buffer} but was of type `+typeof e);this._buffer.push(e),this._sendBufferedData.resolve()}async _sendLoop(){for(;;){if(await this._sendBufferedData.promise,!this._executing){this._transportResult&&this._transportResult.reject("Connection stopped.");break}this._sendBufferedData=new p;const t=this._transportResult;this._transportResult=void 0;var e="string"==typeof this._buffer[0]?this._buffer.join(""):n._concatBuffers(this._buffer);this._buffer.length=0;try{await this._transport.send(e),t.resolve()}catch(e){t.reject(e)}}}static _concatBuffers(e){var t=e.map(e=>e.byteLength).reduce((e,t)=>e+t);const o=new Uint8Array(t);let r=0;for(const n of e)o.set(new Uint8Array(n),r),r+=n.byteLength;return o.buffer}}t.TransportSendQueue=n;class p{constructor(){this.promise=new Promise((e,t)=>[this._resolver,this._rejecter]=[e,t])}resolve(){this._resolver()}reject(e){this._rejecter(e)}}},{"./DefaultHttpClient":2,"./Errors":4,"./HeaderNames":7,"./ILogger":13,"./ITransport":14,"./LongPollingTransport":17,"./ServerSentEventsTransport":18,"./Utils":21,"./WebSocketTransport":22}],10:[function(e,t,o){"use strict";Object.defineProperty(o,"__esModule",{value:!0}),o.HubConnection=o.HubConnectionState=void 0;const n=e("./HandshakeProtocol"),a=e("./IHubProtocol"),i=e("./ILogger"),c=e("./Subject"),s=e("./Utils");var l;(e=l=o.HubConnectionState||(o.HubConnectionState={})).Disconnected="Disconnected",e.Connecting="Connecting",e.Connected="Connected",e.Disconnecting="Disconnecting",e.Reconnecting="Reconnecting";o.HubConnection=class h{constructor(e,t,o,r){this._nextKeepAlive=0,this._freezeEventListener=()=>{this._logger.log(i.LogLevel.Warning,"The page is being frozen, this will likely lead to the connection being closed and messages being lost. For more information see the docs at https://docs.microsoft.com/aspnet/core/signalr/javascript-client#bsleep")},s.Arg.isRequired(e,"connection"),s.Arg.isRequired(t,"logger"),s.Arg.isRequired(o,"protocol"),this.serverTimeoutInMilliseconds=3e4,this.keepAliveIntervalInMilliseconds=15e3,this._logger=t,this._protocol=o,this.connection=e,this._reconnectPolicy=r,this._handshakeProtocol=new n.HandshakeProtocol,this.connection.onreceive=e=>this._processIncomingData(e),this.connection.onclose=e=>this._connectionClosed(e),this._callbacks={},this._methods={},this._closedCallbacks=[],this._reconnectingCallbacks=[],this._reconnectedCallbacks=[],this._invocationId=0,this._receivedHandshakeResponse=!1,this._connectionState=l.Disconnected,this._connectionStarted=!1,this._cachedPingMessage=this._protocol.writeMessage({type:a.MessageType.Ping})}static create(e,t,o,r){return new h(e,t,o,r)}get state(){return this._connectionState}get connectionId(){return this.connection&&this.connection.connectionId||null}get baseUrl(){return this.connection.baseUrl||""}set baseUrl(e){if(this._connectionState!==l.Disconnected&&this._connectionState!==l.Reconnecting)throw new Error("The HubConnection must be in the Disconnected or Reconnecting state to change the url.");if(!e)throw new Error("The HubConnection url must be a valid url.");this.connection.baseUrl=e}start(){return this._startPromise=this._startWithStateTransitions(),this._startPromise}async _startWithStateTransitions(){if(this._connectionState!==l.Disconnected)return Promise.reject(new Error("Cannot start a HubConnection that is not in the 'Disconnected' state."));this._connectionState=l.Connecting,this._logger.log(i.LogLevel.Debug,"Starting HubConnection.");try{await this._startInternal(),s.Platform.isBrowser&&window.document.addEventListener("freeze",this._freezeEventListener),this._connectionState=l.Connected,this._connectionStarted=!0,this._logger.log(i.LogLevel.Debug,"HubConnection connected successfully.")}catch(e){return this._connectionState=l.Disconnected,this._logger.log(i.LogLevel.Debug,`HubConnection failed to start successfully because of error '${e}'.`),Promise.reject(e)}}async _startInternal(){this._stopDuringStartError=void 0,this._receivedHandshakeResponse=!1;var e=new Promise((e,t)=>{this._handshakeResolver=e,this._handshakeRejecter=t});await this.connection.start(this._protocol.transferFormat);try{var t={protocol:this._protocol.name,version:this._protocol.version};if(this._logger.log(i.LogLevel.Debug,"Sending handshake request."),await this._sendMessage(this._handshakeProtocol.writeHandshakeRequest(t)),this._logger.log(i.LogLevel.Information,`Using HubProtocol '${this._protocol.name}'.`),this._cleanupTimeout(),this._resetTimeoutPeriod(),this._resetKeepAliveInterval(),await e,this._stopDuringStartError)throw this._stopDuringStartError}catch(e){throw this._logger.log(i.LogLevel.Debug,`Hub handshake failed with error '${e}' during start(). Stopping HubConnection.`),this._cleanupTimeout(),this._cleanupPingTimer(),await this.connection.stop(e),e}}async stop(){var e=this._startPromise;this._stopPromise=this._stopInternal(),await this._stopPromise;try{await e}catch(e){}}_stopInternal(e){return this._connectionState===l.Disconnected?(this._logger.log(i.LogLevel.Debug,`Call to HubConnection.stop(${e}) ignored because it is already in the disconnected state.`),Promise.resolve()):this._connectionState===l.Disconnecting?(this._logger.log(i.LogLevel.Debug,`Call to HttpConnection.stop(${e}) ignored because the connection is already in the disconnecting state.`),this._stopPromise):(this._connectionState=l.Disconnecting,this._logger.log(i.LogLevel.Debug,"Stopping HubConnection."),this._reconnectDelayHandle?(this._logger.log(i.LogLevel.Debug,"Connection stopped during reconnect delay. Done reconnecting."),clearTimeout(this._reconnectDelayHandle),this._reconnectDelayHandle=void 0,this._completeClose(),Promise.resolve()):(this._cleanupTimeout(),this._cleanupPingTimer(),this._stopDuringStartError=e||new Error("The connection was stopped before the hub handshake could complete."),this.connection.stop(e)))}stream(e,...t){var[o,r]=this._replaceStreamingParams(t);const n=this._createStreamInvocation(e,t,r);let s;const i=new c.Subject;return i.cancelCallback=()=>{const e=this._createCancelInvocation(n.invocationId);return delete this._callbacks[n.invocationId],s.then(()=>this._sendWithProtocol(e))},this._callbacks[n.invocationId]=(e,t)=>{t?i.error(t):e&&(e.type===a.MessageType.Completion?e.error?i.error(new Error(e.error)):i.complete():i.next(e.item))},s=this._sendWithProtocol(n).catch(e=>{i.error(e),delete this._callbacks[n.invocationId]}),this._launchStreams(o,s),i}_sendMessage(e){return this._resetKeepAliveInterval(),this.connection.send(e)}_sendWithProtocol(e){return this._sendMessage(this._protocol.writeMessage(e))}send(e,...t){var[o,r]=this._replaceStreamingParams(t),e=this._sendWithProtocol(this._createInvocation(e,t,!0,r));return this._launchStreams(o,e),e}invoke(e,...t){const[n,o]=this._replaceStreamingParams(t),s=this._createInvocation(e,t,!1,o);return new Promise((o,r)=>{this._callbacks[s.invocationId]=(e,t)=>{t?r(t):e&&(e.type===a.MessageType.Completion?e.error?r(new Error(e.error)):o(e.result):r(new Error("Unexpected message type: "+e.type)))};var e=this._sendWithProtocol(s).catch(e=>{r(e),delete this._callbacks[s.invocationId]});this._launchStreams(n,e)})}on(e,t){e&&t&&(e=e.toLowerCase(),this._methods[e]||(this._methods[e]=[]),-1===this._methods[e].indexOf(t)&&this._methods[e].push(t))}off(e,t){if(e){e=e.toLowerCase();const o=this._methods[e];o&&(t?-1!==(t=o.indexOf(t))&&(o.splice(t,1),0===o.length&&delete this._methods[e]):delete this._methods[e])}}onclose(e){e&&this._closedCallbacks.push(e)}onreconnecting(e){e&&this._reconnectingCallbacks.push(e)}onreconnected(e){e&&this._reconnectedCallbacks.push(e)}_processIncomingData(e){if(this._cleanupTimeout(),this._receivedHandshakeResponse||(e=this._processHandshakeResponse(e),this._receivedHandshakeResponse=!0),e)for(const o of this._protocol.parseMessages(e,this._logger))switch(o.type){case a.MessageType.Invocation:this._invokeClientMethod(o);break;case a.MessageType.StreamItem:case a.MessageType.Completion:{const r=this._callbacks[o.invocationId];if(r){o.type===a.MessageType.Completion&&delete this._callbacks[o.invocationId];try{r(o)}catch(e){this._logger.log(i.LogLevel.Error,"Stream callback threw error: "+s.getErrorString(e))}}break}case a.MessageType.Ping:break;case a.MessageType.Close:this._logger.log(i.LogLevel.Information,"Close message received from server.");var t=o.error?new Error("Server returned an error on close: "+o.error):void 0;!0===o.allowReconnect?this.connection.stop(t):this._stopPromise=this._stopInternal(t);break;default:this._logger.log(i.LogLevel.Warning,`Invalid message type: ${o.type}.`)}this._resetTimeoutPeriod()}_processHandshakeResponse(t){let e,o;try{[o,e]=this._handshakeProtocol.parseHandshakeResponse(t)}catch(e){throw t="Error parsing handshake response: "+e,this._logger.log(i.LogLevel.Error,t),t=new Error(t),this._handshakeRejecter(t),t}if(e.error)throw t="Server returned handshake error: "+e.error,this._logger.log(i.LogLevel.Error,t),t=new Error(t),this._handshakeRejecter(t),t;return this._logger.log(i.LogLevel.Debug,"Server handshake complete."),this._handshakeResolver(),o}_resetKeepAliveInterval(){this.connection.features.inherentKeepAlive||(this._nextKeepAlive=(new Date).getTime()+this.keepAliveIntervalInMilliseconds,this._cleanupPingTimer())}_resetTimeoutPeriod(){if(!(this.connection.features&&this.connection.features.inherentKeepAlive||(this._timeoutHandle=setTimeout(()=>this.serverTimeout(),this.serverTimeoutInMilliseconds),void 0!==this._pingServerHandle))){let e=this._nextKeepAlive-(new Date).getTime();e<0&&(e=0),this._pingServerHandle=setTimeout(async()=>{if(this._connectionState===l.Connected)try{await this._sendMessage(this._cachedPingMessage)}catch{this._cleanupPingTimer()}},e)}}serverTimeout(){this.connection.stop(new Error("Server timeout elapsed without receiving a message from the server."))}_invokeClientMethod(t){const e=this._methods[t.target.toLowerCase()];if(e){try{e.forEach(e=>e.apply(this,t.arguments))}catch(e){this._logger.log(i.LogLevel.Error,`A callback for the method ${t.target.toLowerCase()} threw error '${e}'.`)}var o;t.invocationId&&(o="Server requested a response, which is not supported in this version of the client.",this._logger.log(i.LogLevel.Error,o),this._stopPromise=this._stopInternal(new Error(o)))}else this._logger.log(i.LogLevel.Warning,`No client method with the name '${t.target}' found.`)}_connectionClosed(e){this._logger.log(i.LogLevel.Debug,`HubConnection.connectionClosed(${e}) called while in state ${this._connectionState}.`),this._stopDuringStartError=this._stopDuringStartError||e||new Error("The underlying connection was closed before the hub handshake could complete."),this._handshakeResolver&&this._handshakeResolver(),this._cancelCallbacksWithError(e||new Error("Invocation canceled due to the underlying connection being closed.")),this._cleanupTimeout(),this._cleanupPingTimer(),this._connectionState===l.Disconnecting?this._completeClose(e):this._connectionState===l.Connected&&this._reconnectPolicy?this._reconnect(e):this._connectionState===l.Connected&&this._completeClose(e)}_completeClose(t){if(this._connectionStarted){this._connectionState=l.Disconnected,this._connectionStarted=!1,s.Platform.isBrowser&&window.document.removeEventListener("freeze",this._freezeEventListener);try{this._closedCallbacks.forEach(e=>e.apply(this,[t]))}catch(e){this._logger.log(i.LogLevel.Error,`An onclose callback called with error '${t}' threw error '${e}'.`)}}}async _reconnect(t){var o=Date.now();let r=0;var n=void 0!==t?t:new Error("Attempting to reconnect due to a unknown error.");let s=this._getNextRetryDelay(r++,0,n);if(null===s)this._logger.log(i.LogLevel.Debug,"Connection not reconnecting because the IRetryPolicy returned null on the first reconnect attempt."),this._completeClose(t);else{if(this._connectionState=l.Reconnecting,t?this._logger.log(i.LogLevel.Information,`Connection reconnecting because of error '${t}'.`):this._logger.log(i.LogLevel.Information,"Connection reconnecting."),0!==this._reconnectingCallbacks.length){try{this._reconnectingCallbacks.forEach(e=>e.apply(this,[t]))}catch(e){this._logger.log(i.LogLevel.Error,`An onreconnecting callback called with error '${t}' threw error '${e}'.`)}if(this._connectionState!==l.Reconnecting)return void this._logger.log(i.LogLevel.Debug,"Connection left the reconnecting state in onreconnecting callback. Done reconnecting.")}for(;null!==s;){if(this._logger.log(i.LogLevel.Information,`Reconnect attempt number ${r} will start in ${s} ms.`),await new Promise(e=>{this._reconnectDelayHandle=setTimeout(e,s)}),this._reconnectDelayHandle=void 0,this._connectionState!==l.Reconnecting)return void this._logger.log(i.LogLevel.Debug,"Connection left the reconnecting state during reconnect delay. Done reconnecting.");try{if(await this._startInternal(),this._connectionState=l.Connected,this._logger.log(i.LogLevel.Information,"HubConnection reconnected successfully."),0!==this._reconnectedCallbacks.length)try{this._reconnectedCallbacks.forEach(e=>e.apply(this,[this.connection.connectionId]))}catch(e){this._logger.log(i.LogLevel.Error,`An onreconnected callback called with connectionId '${this.connection.connectionId}; threw error '${e}'.`)}return}catch(e){if(this._logger.log(i.LogLevel.Information,`Reconnect attempt failed because of error '${e}'.`),this._connectionState!==l.Reconnecting)return this._logger.log(i.LogLevel.Debug,`Connection moved to the '${this._connectionState}' from the reconnecting state during reconnect attempt. Done reconnecting.`),void(this._connectionState===l.Disconnecting&&this._completeClose());n=e instanceof Error?e:new Error(e.toString()),s=this._getNextRetryDelay(r++,Date.now()-o,n)}}this._logger.log(i.LogLevel.Information,`Reconnect retries have been exhausted after ${Date.now()-o} ms and ${r} failed attempts. Connection disconnecting.`),this._completeClose()}}_getNextRetryDelay(t,o,e){try{return this._reconnectPolicy.nextRetryDelayInMilliseconds({elapsedMilliseconds:o,previousRetryCount:t,retryReason:e})}catch(e){return this._logger.log(i.LogLevel.Error,`IRetryPolicy.nextRetryDelayInMilliseconds(${t}, ${o}) threw error '${e}'.`),null}}_cancelCallbacksWithError(o){const r=this._callbacks;this._callbacks={},Object.keys(r).forEach(e=>{const t=r[e];try{t(null,o)}catch(e){this._logger.log(i.LogLevel.Error,`Stream 'error' callback called with '${o}' threw error: `+s.getErrorString(e))}})}_cleanupPingTimer(){this._pingServerHandle&&(clearTimeout(this._pingServerHandle),this._pingServerHandle=void 0)}_cleanupTimeout(){this._timeoutHandle&&clearTimeout(this._timeoutHandle)}_createInvocation(e,t,o,r){if(o)return 0!==r.length?{arguments:t,streamIds:r,target:e,type:a.MessageType.Invocation}:{arguments:t,target:e,type:a.MessageType.Invocation};{const n=this._invocationId;return this._invocationId++,0!==r.length?{arguments:t,invocationId:n.toString(),streamIds:r,target:e,type:a.MessageType.Invocation}:{arguments:t,invocationId:n.toString(),target:e,type:a.MessageType.Invocation}}}_launchStreams(e,o){if(0!==e.length){o=o||Promise.resolve();for(const r in e)e[r].subscribe({complete:()=>{o=o.then(()=>this._sendWithProtocol(this._createCompletionMessage(r)))},error:e=>{let t;t=e instanceof Error?e.message:e&&e.toString?e.toString():"Unknown error",o=o.then(()=>this._sendWithProtocol(this._createCompletionMessage(r,t)))},next:e=>{o=o.then(()=>this._sendWithProtocol(this._createStreamItemMessage(r,e)))}})}}_replaceStreamingParams(t){const o=[],r=[];for(let e=0;e<t.length;e++){var n=t[e];if(this._isObservable(n)){const s=this._invocationId;this._invocationId++,o[s]=n,r.push(s.toString()),t.splice(e,1)}}return[o,r]}_isObservable(e){return e&&e.subscribe&&"function"==typeof e.subscribe}_createStreamInvocation(e,t,o){const r=this._invocationId;return this._invocationId++,0!==o.length?{arguments:t,invocationId:r.toString(),streamIds:o,target:e,type:a.MessageType.StreamInvocation}:{arguments:t,invocationId:r.toString(),target:e,type:a.MessageType.StreamInvocation}}_createCancelInvocation(e){return{invocationId:e,type:a.MessageType.CancelInvocation}}_createStreamItemMessage(e,t){return{invocationId:e,item:t,type:a.MessageType.StreamItem}}_createCompletionMessage(e,t,o){return t?{error:t,invocationId:e,type:a.MessageType.Completion}:{invocationId:e,result:o,type:a.MessageType.Completion}}}},{"./HandshakeProtocol":6,"./IHubProtocol":12,"./ILogger":13,"./Subject":19,"./Utils":21}],11:[function(e,t,o){"use strict";Object.defineProperty(o,"__esModule",{value:!0}),o.HubConnectionBuilder=void 0;const r=e("./DefaultReconnectPolicy"),n=e("./HttpConnection"),s=e("./HubConnection");var i=e("./ILogger");const a=e("./JsonHubProtocol"),c=e("./Loggers"),l=e("./Utils"),h={trace:i.LogLevel.Trace,debug:i.LogLevel.Debug,info:i.LogLevel.Information,information:i.LogLevel.Information,warn:i.LogLevel.Warning,warning:i.LogLevel.Warning,error:i.LogLevel.Error,critical:i.LogLevel.Critical,none:i.LogLevel.None};o.HubConnectionBuilder=class{configureLogging(e){var t;return l.Arg.isRequired(e,"logging"),void 0!==e.log?this.logger=e:"string"==typeof e?(t=function(e){var t=h[e.toLowerCase()];if(void 0!==t)return t;throw new Error("Unknown log level: "+e)}(e),this.logger=new l.ConsoleLogger(t)):this.logger=new l.ConsoleLogger(e),this}withUrl(e,t){return l.Arg.isRequired(e,"url"),l.Arg.isNotEmpty(e,"url"),this.url=e,this.httpConnectionOptions="object"==typeof t?{...this.httpConnectionOptions,...t}:{...this.httpConnectionOptions,transport:t},this}withHubProtocol(e){return l.Arg.isRequired(e,"protocol"),this.protocol=e,this}withAutomaticReconnect(e){if(this.reconnectPolicy)throw new Error("A reconnectPolicy has already been set.");return e?Array.isArray(e)?this.reconnectPolicy=new r.DefaultReconnectPolicy(e):this.reconnectPolicy=e:this.reconnectPolicy=new r.DefaultReconnectPolicy,this}build(){const e=this.httpConnectionOptions||{};var t;if(void 0===e.logger&&(e.logger=this.logger),this.url)return t=new n.HttpConnection(this.url,e),s.HubConnection.create(t,this.logger||c.NullLogger.instance,this.protocol||new a.JsonHubProtocol,this.reconnectPolicy);throw new Error("The 'HubConnectionBuilder.withUrl' method must be called before building the connection.")}}},{"./DefaultReconnectPolicy":3,"./HttpConnection":9,"./HubConnection":10,"./ILogger":13,"./JsonHubProtocol":15,"./Loggers":16,"./Utils":21}],12:[function(e,t,o){"use strict";Object.defineProperty(o,"__esModule",{value:!0}),o.MessageType=void 0,(o=o.MessageType||(o.MessageType={}))[o.Invocation=1]="Invocation",o[o.StreamItem=2]="StreamItem",o[o.Completion=3]="Completion",o[o.StreamInvocation=4]="StreamInvocation",o[o.CancelInvocation=5]="CancelInvocation",o[o.Ping=6]="Ping",o[o.Close=7]="Close"},{}],13:[function(e,t,o){"use strict";Object.defineProperty(o,"__esModule",{value:!0}),o.LogLevel=void 0,(o=o.LogLevel||(o.LogLevel={}))[o.Trace=0]="Trace",o[o.Debug=1]="Debug",o[o.Information=2]="Information",o[o.Warning=3]="Warning",o[o.Error=4]="Error",o[o.Critical=5]="Critical",o[o.None=6]="None"},{}],14:[function(e,t,o){"use strict";var r;Object.defineProperty(o,"__esModule",{value:!0}),o.TransferFormat=o.HttpTransportType=void 0,(r=o.HttpTransportType||(o.HttpTransportType={}))[r.None=0]="None",r[r.WebSockets=1]="WebSockets",r[r.ServerSentEvents=2]="ServerSentEvents",r[r.LongPolling=4]="LongPolling",(r=o.TransferFormat||(o.TransferFormat={}))[r.Text=1]="Text",r[r.Binary=2]="Binary"},{}],15:[function(e,t,o){"use strict";Object.defineProperty(o,"__esModule",{value:!0}),o.JsonHubProtocol=void 0;const s=e("./IHubProtocol"),i=e("./ILogger"),r=e("./ITransport"),a=e("./Loggers"),c=e("./TextMessageFormat");o.JsonHubProtocol=class{constructor(){this.name="json",this.version=1,this.transferFormat=r.TransferFormat.Text}parseMessages(e,t){if("string"!=typeof e)throw new Error("Invalid input for JSON hub protocol. Expected a string.");if(!e)return[];null===t&&(t=a.NullLogger.instance);const o=[];for(const n of c.TextMessageFormat.parse(e)){var r=JSON.parse(n);if("number"!=typeof r.type)throw new Error("Invalid payload.");switch(r.type){case s.MessageType.Invocation:this._isInvocationMessage(r);break;case s.MessageType.StreamItem:this._isStreamItemMessage(r);break;case s.MessageType.Completion:this._isCompletionMessage(r);break;case s.MessageType.Ping:case s.MessageType.Close:break;default:t.log(i.LogLevel.Information,"Unknown message type '"+r.type+"' ignored.");continue}o.push(r)}return o}writeMessage(e){return c.TextMessageFormat.write(JSON.stringify(e))}_isInvocationMessage(e){this._assertNotEmptyString(e.target,"Invalid payload for Invocation message."),void 0!==e.invocationId&&this._assertNotEmptyString(e.invocationId,"Invalid payload for Invocation message.")}_isStreamItemMessage(e){if(this._assertNotEmptyString(e.invocationId,"Invalid payload for StreamItem message."),void 0===e.item)throw new Error("Invalid payload for StreamItem message.")}_isCompletionMessage(e){if(e.result&&e.error)throw new Error("Invalid payload for Completion message.");!e.result&&e.error&&this._assertNotEmptyString(e.error,"Invalid payload for Completion message."),this._assertNotEmptyString(e.invocationId,"Invalid payload for Completion message.")}_assertNotEmptyString(e,t){if("string"!=typeof e||""===e)throw new Error(t)}}},{"./IHubProtocol":12,"./ILogger":13,"./ITransport":14,"./Loggers":16,"./TextMessageFormat":20}],16:[function(e,t,o){"use strict";Object.defineProperty(o,"__esModule",{value:!0}),o.NullLogger=void 0;class r{constructor(){}log(e,t){}}(o.NullLogger=r).instance=new r},{}],17:[function(e,t,o){"use strict";Object.defineProperty(o,"__esModule",{value:!0}),o.LongPollingTransport=void 0;const n=e("./AbortController"),s=e("./Errors"),r=e("./HeaderNames"),i=e("./ILogger"),a=e("./ITransport"),c=e("./Utils");o.LongPollingTransport=class{constructor(e,t,o,r){this._httpClient=e,this._accessTokenFactory=t,this._logger=o,this._pollAbort=new n.AbortController,this._options=r,this._running=!1,this.onreceive=null,this.onclose=null}get pollAborted(){return this._pollAbort.aborted}async connect(e,t){if(c.Arg.isRequired(e,"url"),c.Arg.isRequired(t,"transferFormat"),c.Arg.isIn(t,a.TransferFormat,"transferFormat"),this._url=e,this._logger.log(i.LogLevel.Trace,"(LongPolling transport) Connecting."),t===a.TransferFormat.Binary&&"undefined"!=typeof XMLHttpRequest&&"string"!=typeof(new XMLHttpRequest).responseType)throw new Error("Binary protocols over XmlHttpRequest not implementing advanced features are not supported.");var[o,r]=c.getUserAgentHeader(),o={[o]:r,...this._options.headers};const n={abortSignal:this._pollAbort.signal,headers:o,timeout:1e5,withCredentials:this._options.withCredentials};t===a.TransferFormat.Binary&&(n.responseType="arraybuffer");r=await this._getAccessToken(),this._updateHeaderToken(n,r),o=e+"&_="+Date.now(),this._logger.log(i.LogLevel.Trace,`(LongPolling transport) polling: ${o}.`),t=await this._httpClient.get(o,n);200!==t.statusCode?(this._logger.log(i.LogLevel.Error,`(LongPolling transport) Unexpected response code: ${t.statusCode}.`),this._closeError=new s.HttpError(t.statusText||"",t.statusCode),this._running=!1):this._running=!0,this._receiving=this._poll(this._url,n)}async _getAccessToken(){return this._accessTokenFactory?this._accessTokenFactory():null}_updateHeaderToken(e,t){e.headers||(e.headers={}),t?e.headers[r.HeaderNames.Authorization]="Bearer "+t:e.headers[r.HeaderNames.Authorization]&&delete e.headers[r.HeaderNames.Authorization]}async _poll(e,t){try{for(;this._running;){var o=await this._getAccessToken();this._updateHeaderToken(t,o);try{var r=e+"&_="+Date.now(),n=(this._logger.log(i.LogLevel.Trace,`(LongPolling transport) polling: ${r}.`),await this._httpClient.get(r,t));204===n.statusCode?(this._logger.log(i.LogLevel.Information,"(LongPolling transport) Poll terminated by server."),this._running=!1):200!==n.statusCode?(this._logger.log(i.LogLevel.Error,`(LongPolling transport) Unexpected response code: ${n.statusCode}.`),this._closeError=new s.HttpError(n.statusText||"",n.statusCode),this._running=!1):n.content?(this._logger.log(i.LogLevel.Trace,`(LongPolling transport) data received. ${c.getDataDetail(n.content,this._options.logMessageContent)}.`),this.onreceive&&this.onreceive(n.content)):this._logger.log(i.LogLevel.Trace,"(LongPolling transport) Poll timed out, reissuing.")}catch(e){this._running?e instanceof s.TimeoutError?this._logger.log(i.LogLevel.Trace,"(LongPolling transport) Poll timed out, reissuing."):(this._closeError=e,this._running=!1):this._logger.log(i.LogLevel.Trace,"(LongPolling transport) Poll errored after shutdown: "+e.message)}}}finally{this._logger.log(i.LogLevel.Trace,"(LongPolling transport) Polling complete."),this.pollAborted||this._raiseOnClose()}}async send(e){return this._running?c.sendMessage(this._logger,"LongPolling",this._httpClient,this._url,this._accessTokenFactory,e,this._options):Promise.reject(new Error("Cannot send until the transport is connected"))}async stop(){this._logger.log(i.LogLevel.Trace,"(LongPolling transport) Stopping polling."),this._running=!1,this._pollAbort.abort();try{await this._receiving,this._logger.log(i.LogLevel.Trace,`(LongPolling transport) sending DELETE request to ${this._url}.`);const n={};var[e,t]=c.getUserAgentHeader(),o=(n[e]=t,{headers:{...n,...this._options.headers},timeout:this._options.timeout,withCredentials:this._options.withCredentials}),r=await this._getAccessToken();this._updateHeaderToken(o,r),await this._httpClient.delete(this._url,o),this._logger.log(i.LogLevel.Trace,"(LongPolling transport) DELETE request sent.")}finally{this._logger.log(i.LogLevel.Trace,"(LongPolling transport) Stop finished."),this._raiseOnClose()}}_raiseOnClose(){if(this.onclose){let e="(LongPolling transport) Firing onclose event.";this._closeError&&(e+=" Error: "+this._closeError),this._logger.log(i.LogLevel.Trace,e),this.onclose(this._closeError)}}}},{"./AbortController":1,"./Errors":4,"./HeaderNames":7,"./ILogger":13,"./ITransport":14,"./Utils":21}],18:[function(e,t,o){"use strict";Object.defineProperty(o,"__esModule",{value:!0}),o.ServerSentEventsTransport=void 0;const c=e("./ILogger"),l=e("./ITransport"),h=e("./Utils");o.ServerSentEventsTransport=class{constructor(e,t,o,r){this._httpClient=e,this._accessTokenFactory=t,this._logger=o,this._options=r,this.onreceive=null,this.onclose=null}async connect(a,e){var t;return h.Arg.isRequired(a,"url"),h.Arg.isRequired(e,"transferFormat"),h.Arg.isIn(e,l.TransferFormat,"transferFormat"),this._logger.log(c.LogLevel.Trace,"(SSE transport) Connecting."),this._url=a,this._accessTokenFactory&&(t=await this._accessTokenFactory())&&(a+=(a.indexOf("?")<0?"?":"&")+"access_token="+encodeURIComponent(t)),new Promise((t,o)=>{let r=!1;if(e!==l.TransferFormat.Text)o(new Error("The Server-Sent Events transport only supports the 'Text' transfer format"));else{let e;if(h.Platform.isBrowser||h.Platform.isWebWorker)e=new this._options.EventSource(a,{withCredentials:this._options.withCredentials});else{var n=this._httpClient.getCookieString(a);const i={};i.Cookie=n;var[n,s]=h.getUserAgentHeader();i[n]=s,e=new this._options.EventSource(a,{withCredentials:this._options.withCredentials,headers:{...i,...this._options.headers}})}try{e.onmessage=e=>{if(this.onreceive)try{this._logger.log(c.LogLevel.Trace,`(SSE transport) data received. ${h.getDataDetail(e.data,this._options.logMessageContent)}.`),this.onreceive(e.data)}catch(e){this._close(e)}},e.onerror=e=>{r?this._close():o(new Error("EventSource failed to connect. The connection could not be found on the server, either the connection ID is not present on the server, or a proxy is refusing/buffering the connection. If you have multiple servers check that sticky sessions are enabled."))},e.onopen=()=>{this._logger.log(c.LogLevel.Information,"SSE connected to "+this._url),this._eventSource=e,r=!0,t()}}catch(e){o(e)}}})}async send(e){return this._eventSource?h.sendMessage(this._logger,"SSE",this._httpClient,this._url,this._accessTokenFactory,e,this._options):Promise.reject(new Error("Cannot send until the transport is connected"))}stop(){return this._close(),Promise.resolve()}_close(e){this._eventSource&&(this._eventSource.close(),this._eventSource=void 0,this.onclose&&this.onclose(e))}}},{"./ILogger":13,"./ITransport":14,"./Utils":21}],19:[function(e,t,o){"use strict";Object.defineProperty(o,"__esModule",{value:!0}),o.Subject=void 0;const r=e("./Utils");o.Subject=class{constructor(){this.observers=[]}next(e){for(const t of this.observers)t.next(e)}error(e){for(const t of this.observers)t.error&&t.error(e)}complete(){for(const e of this.observers)e.complete&&e.complete()}subscribe(e){return this.observers.push(e),new r.SubjectSubscription(this,e)}}},{"./Utils":21}],20:[function(e,t,o){"use strict";Object.defineProperty(o,"__esModule",{value:!0}),o.TextMessageFormat=void 0;class r{static write(e){return""+e+r.RecordSeparator}static parse(e){if(e[e.length-1]!==r.RecordSeparator)throw new Error("Message is incomplete.");const t=e.split(r.RecordSeparator);return t.pop(),t}}(o.TextMessageFormat=r).RecordSeparatorCode=30,r.RecordSeparator=String.fromCharCode(r.RecordSeparatorCode)},{}],21:[function(a,e,c){!function(i,e){!function(){"use strict";Object.defineProperty(c,"__esModule",{value:!0}),c.getGlobalThis=c.getErrorString=c.constructUserAgent=c.getUserAgentHeader=c.ConsoleLogger=c.SubjectSubscription=c.createLogger=c.sendMessage=c.isArrayBuffer=c.formatArrayBuffer=c.getDataDetail=c.Platform=c.Arg=c.VERSION=void 0;const l=a("./ILogger"),t=a("./Loggers");c.VERSION="6.0.9";c.Arg=class{static isRequired(e,t){if(null==e)throw new Error(`The '${t}' argument is required.`)}static isNotEmpty(e,t){if(!e||e.match(/^\s*$/))throw new Error(`The '${t}' argument should not be empty.`)}static isIn(e,t,o){if(!(e in t))throw new Error(`Unknown ${o} value: ${e}.`)}};class o{static get isBrowser(){return"object"==typeof window&&"object"==typeof window.document}static get isWebWorker(){return"object"==typeof self&&"importScripts"in self}static get isReactNative(){return"object"==typeof window&&void 0===window.document}static get isNode(){return!this.isBrowser&&!this.isWebWorker&&!this.isReactNative}}function h(e,t){let o="";return g(e)?(o="Binary data of length "+e.byteLength,t&&(o+=`. Content: '${r(e)}'`)):"string"==typeof e&&(o="String data of length "+e.length,t&&(o+=`. Content: '${e}'`)),o}function r(e){const t=new Uint8Array(e);let o="";return t.forEach(e=>{var t=e<16?"0":"";o+=`0x${t}${e.toString(16)} `}),o.substr(0,o.length-1)}function g(e){return e&&"undefined"!=typeof ArrayBuffer&&(e instanceof ArrayBuffer||e.constructor&&"ArrayBuffer"===e.constructor.name)}c.Platform=o,c.getDataDetail=h,c.formatArrayBuffer=r,c.isArrayBuffer=g,c.sendMessage=async function(e,t,o,r,n,s,i){let a={};(n=n&&await n())&&(a={Authorization:"Bearer "+n});var[n,c]=u(),n=(a[n]=c,e.log(l.LogLevel.Trace,`(${t} transport) sending data. ${h(s,i.logMessageContent)}.`),g(s)?"arraybuffer":"text"),c=await o.post(r,{content:s,headers:{...a,...i.headers},responseType:n,timeout:i.timeout,withCredentials:i.withCredentials});e.log(l.LogLevel.Trace,`(${t} transport) request complete. Response status: ${c.statusCode}.`)},c.createLogger=function(e){return void 0===e?new n(l.LogLevel.Information):null===e?t.NullLogger.instance:void 0!==e.log?e:new n(e)};c.SubjectSubscription=class{constructor(e,t){this._subject=e,this._observer=t}dispose(){var e=this._subject.observers.indexOf(this._observer);-1<e&&this._subject.observers.splice(e,1),0===this._subject.observers.length&&this._subject.cancelCallback&&this._subject.cancelCallback().catch(e=>{})}};class n{constructor(e){this._minLevel=e,this.out=console}log(e,t){if(e>=this._minLevel){var o=`[${(new Date).toISOString()}] ${l.LogLevel[e]}: `+t;switch(e){case l.LogLevel.Critical:case l.LogLevel.Error:this.out.error(o);break;case l.LogLevel.Warning:this.out.warn(o);break;case l.LogLevel.Information:this.out.info(o);break;default:this.out.log(o)}}}}function u(){let e="X-SignalR-User-Agent";return[e=o.isNode?"User-Agent":e,s(c.VERSION,function(){{if(!o.isNode)return"";switch(i.platform){case"win32":return"Windows NT";case"darwin":return"macOS";case"linux":return"Linux";default:return i.platform}}}(),o.isNode?"NodeJS":"Browser",function(){if(o.isNode)return i.versions.node;return}())]}function s(e,t,o,r){let n="Microsoft SignalR/";var s=e.split(".");return n=(n=(n=n+(s[0]+"."+s[1])+` (${e}; `)+(t&&""!==t?t+"; ":"Unknown OS; ")+(""+o))+(r?"; "+r:"; Unknown Runtime Version")+")"}c.ConsoleLogger=n,c.getUserAgentHeader=u,c.constructUserAgent=s,c.getErrorString=function(e){return e.stack||e.message||""+e},c.getGlobalThis=function(){if("undefined"!=typeof globalThis)return globalThis;if("undefined"!=typeof self)return self;if("undefined"!=typeof window)return window;if(void 0!==e)return e;throw new Error("could not find global")}}.call(this)}.call(this,a("_process"),"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{"./ILogger":13,"./Loggers":16,_process:25}],22:[function(e,t,o){"use strict";Object.defineProperty(o,"__esModule",{value:!0}),o.WebSocketTransport=void 0;const h=e("./HeaderNames"),g=e("./ILogger"),u=e("./ITransport"),p=e("./Utils");o.WebSocketTransport=class{constructor(e,t,o,r,n,s){this._logger=o,this._accessTokenFactory=t,this._logMessageContent=r,this._webSocketConstructor=n,this._httpClient=e,this.onreceive=null,this.onclose=null,this._headers=s}async connect(c,l){var e;return p.Arg.isRequired(c,"url"),p.Arg.isRequired(l,"transferFormat"),p.Arg.isIn(l,u.TransferFormat,"transferFormat"),this._logger.log(g.LogLevel.Trace,"(WebSockets transport) Connecting."),this._accessTokenFactory&&(e=await this._accessTokenFactory())&&(c+=(c.indexOf("?")<0?"?":"&")+"access_token="+encodeURIComponent(e)),new Promise((t,o)=>{c=c.replace(/^http/,"ws");let r;var e=this._httpClient.getCookieString(c);let n=!1;if(p.Platform.isNode){const a={};var[s,i]=p.getUserAgentHeader();a[s]=i,e&&(a[h.HeaderNames.Cookie]=""+e),r=new this._webSocketConstructor(c,void 0,{headers:{...a,...this._headers}})}r=r||new this._webSocketConstructor(c),l===u.TransferFormat.Binary&&(r.binaryType="arraybuffer"),r.onopen=e=>{this._logger.log(g.LogLevel.Information,`WebSocket connected to ${c}.`),this._webSocket=r,n=!0,t()},r.onerror=e=>{let t=null;t="undefined"!=typeof ErrorEvent&&e instanceof ErrorEvent?e.error:"There was an error with the transport",this._logger.log(g.LogLevel.Information,`(WebSockets transport) ${t}.`)},r.onmessage=e=>{if(this._logger.log(g.LogLevel.Trace,`(WebSockets transport) data received. ${p.getDataDetail(e.data,this._logMessageContent)}.`),this.onreceive)try{this.onreceive(e.data)}catch(e){this._close(e)}},r.onclose=t=>{if(n)this._close(t);else{let e=null;e="undefined"!=typeof ErrorEvent&&t instanceof ErrorEvent?t.error:"WebSocket failed to connect. The connection could not be found on the server, either the endpoint may not be a SignalR endpoint, the connection ID is not present on the server, or there is a proxy blocking WebSockets. If you have multiple servers check that sticky sessions are enabled.",o(new Error(e))}}})}send(e){return this._webSocket&&this._webSocket.readyState===this._webSocketConstructor.OPEN?(this._logger.log(g.LogLevel.Trace,`(WebSockets transport) sending data. ${p.getDataDetail(e,this._logMessageContent)}.`),this._webSocket.send(e),Promise.resolve()):Promise.reject("WebSocket is not in the OPEN state")}stop(){return this._webSocket&&this._close(void 0),Promise.resolve()}_close(e){this._webSocket&&(this._webSocket.onclose=()=>{},this._webSocket.onmessage=()=>{},this._webSocket.onerror=()=>{},this._webSocket.close(),this._webSocket=void 0),this._logger.log(g.LogLevel.Trace,"(WebSockets transport) socket closed."),this.onclose&&(!this._isCloseEvent(e)||!1!==e.wasClean&&1e3===e.code?e instanceof Error?this.onclose(e):this.onclose():this.onclose(new Error(`WebSocket closed with status code: ${e.code} (${e.reason||"no reason given"}).`)))}_isCloseEvent(e){return e&&"boolean"==typeof e.wasClean&&"number"==typeof e.code}}},{"./HeaderNames":7,"./ILogger":13,"./ITransport":14,"./Utils":21}],23:[function(e,t,o){"use strict";Object.defineProperty(o,"__esModule",{value:!0}),o.XhrHttpClient=void 0;const s=e("./Errors"),i=e("./HttpClient"),a=e("./ILogger");class r extends i.HttpClient{constructor(e){super(),this._logger=e}send(n){return n.abortSignal&&n.abortSignal.aborted?Promise.reject(new s.AbortError):n.method?n.url?new Promise((e,t)=>{const o=new XMLHttpRequest,r=(o.open(n.method,n.url,!0),o.withCredentials=void 0===n.withCredentials||n.withCredentials,o.setRequestHeader("X-Requested-With","XMLHttpRequest"),o.setRequestHeader("Content-Type","text/plain;charset=UTF-8"),n.headers);r&&Object.keys(r).forEach(e=>{o.setRequestHeader(e,r[e])}),n.responseType&&(o.responseType=n.responseType),n.abortSignal&&(n.abortSignal.onabort=()=>{o.abort(),t(new s.AbortError)}),n.timeout&&(o.timeout=n.timeout),o.onload=()=>{n.abortSignal&&(n.abortSignal.onabort=null),200<=o.status&&o.status<300?e(new i.HttpResponse(o.status,o.statusText,o.response||o.responseText)):t(new s.HttpError(o.response||o.responseText||o.statusText,o.status))},o.onerror=()=>{this._logger.log(a.LogLevel.Warning,`Error from HTTP request. ${o.status}: ${o.statusText}.`),t(new s.HttpError(o.statusText,o.status))},o.ontimeout=()=>{this._logger.log(a.LogLevel.Warning,"Timeout from HTTP request."),t(new s.TimeoutError)},o.send(n.content||"")}):Promise.reject(new Error("No url defined.")):Promise.reject(new Error("No method defined."))}}o.XhrHttpClient=r},{"./Errors":4,"./HttpClient":8,"./ILogger":13}],24:[function(e,t,o){"use strict";Object.defineProperty(o,"__esModule",{value:!0}),o.VERSION=o.Subject=o.JsonHubProtocol=o.NullLogger=o.TransferFormat=o.HttpTransportType=o.LogLevel=o.MessageType=o.HubConnectionBuilder=o.HubConnectionState=o.HubConnection=o.DefaultHttpClient=o.HttpResponse=o.HttpClient=o.TimeoutError=o.HttpError=o.AbortError=void 0;var r=e("./Errors"),n=(Object.defineProperty(o,"AbortError",{enumerable:!0,get:function(){return r.AbortError}}),Object.defineProperty(o,"HttpError",{enumerable:!0,get:function(){return r.HttpError}}),Object.defineProperty(o,"TimeoutError",{enumerable:!0,get:function(){return r.TimeoutError}}),e("./HttpClient")),s=(Object.defineProperty(o,"HttpClient",{enumerable:!0,get:function(){return n.HttpClient}}),Object.defineProperty(o,"HttpResponse",{enumerable:!0,get:function(){return n.HttpResponse}}),e("./DefaultHttpClient")),i=(Object.defineProperty(o,"DefaultHttpClient",{enumerable:!0,get:function(){return s.DefaultHttpClient}}),e("./HubConnection")),a=(Object.defineProperty(o,"HubConnection",{enumerable:!0,get:function(){return i.HubConnection}}),Object.defineProperty(o,"HubConnectionState",{enumerable:!0,get:function(){return i.HubConnectionState}}),e("./HubConnectionBuilder")),c=(Object.defineProperty(o,"HubConnectionBuilder",{enumerable:!0,get:function(){return a.HubConnectionBuilder}}),e("./IHubProtocol")),l=(Object.defineProperty(o,"MessageType",{enumerable:!0,get:function(){return c.MessageType}}),e("./ILogger")),h=(Object.defineProperty(o,"LogLevel",{enumerable:!0,get:function(){return l.LogLevel}}),e("./ITransport")),g=(Object.defineProperty(o,"HttpTransportType",{enumerable:!0,get:function(){return h.HttpTransportType}}),Object.defineProperty(o,"TransferFormat",{enumerable:!0,get:function(){return h.TransferFormat}}),e("./Loggers")),u=(Object.defineProperty(o,"NullLogger",{enumerable:!0,get:function(){return g.NullLogger}}),e("./JsonHubProtocol")),p=(Object.defineProperty(o,"JsonHubProtocol",{enumerable:!0,get:function(){return u.JsonHubProtocol}}),e("./Subject")),d=(Object.defineProperty(o,"Subject",{enumerable:!0,get:function(){return p.Subject}}),e("./Utils"));Object.defineProperty(o,"VERSION",{enumerable:!0,get:function(){return d.VERSION}})},{"./DefaultHttpClient":2,"./Errors":4,"./HttpClient":8,"./HubConnection":10,"./HubConnectionBuilder":11,"./IHubProtocol":12,"./ILogger":13,"./ITransport":14,"./JsonHubProtocol":15,"./Loggers":16,"./Subject":19,"./Utils":21}],25:[function(e,t,o){var r,n,t=t.exports={};function s(){throw new Error("setTimeout has not been defined")}function i(){throw new Error("clearTimeout has not been defined")}try{r="function"==typeof setTimeout?setTimeout:s}catch(e){r=s}try{n="function"==typeof clearTimeout?clearTimeout:i}catch(e){n=i}function a(t){if(r===setTimeout)return setTimeout(t,0);if((r===s||!r)&&setTimeout)return(r=setTimeout)(t,0);try{return r(t,0)}catch(e){try{return r.call(null,t,0)}catch(e){return r.call(this,t,0)}}}var c,l=[],h=!1,g=-1;function u(){h&&c&&(h=!1,c.length?l=c.concat(l):g=-1,l.length&&p())}function p(){if(!h){for(var e=a(u),t=(h=!0,l.length);t;){for(c=l,l=[];++g<t;)c&&c[g].run();g=-1,t=l.length}c=null,h=!1,!function(t){if(n===clearTimeout)return clearTimeout(t);if((n===i||!n)&&clearTimeout)return(n=clearTimeout)(t);try{n(t)}catch(e){try{return n.call(null,t)}catch(e){return n.call(this,t)}}}(e)}}function d(e,t){this.fun=e,this.array=t}function _(){}t.nextTick=function(e){var t=new Array(arguments.length-1);if(1<arguments.length)for(var o=1;o<arguments.length;o++)t[o-1]=arguments[o];l.push(new d(e,t)),1!==l.length||h||a(p)},d.prototype.run=function(){this.fun.apply(null,this.array)},t.title="browser",t.browser=!0,t.env={},t.argv=[],t.version="",t.versions={},t.on=_,t.addListener=_,t.once=_,t.off=_,t.removeListener=_,t.removeAllListeners=_,t.emit=_,t.prependListener=_,t.prependOnceListener=_,t.listeners=function(e){return[]},t.binding=function(e){throw new Error("process.binding is not supported")},t.cwd=function(){return"/"},t.chdir=function(e){throw new Error("process.chdir is not supported")},t.umask=function(){return 0}},{}],26:[function(e,t,o){"use strict";Object.defineProperty(o,"__esModule",{value:!0}),o.ApiModule=o.get=o.extend=void 0,o.extend=function(e,t){window.__iat_api||window.__iat_api||(window.__iat_api={}),window.__iat_api[e.toString()]=t},o.get=function(e){return window.__iat_api[e.toString()]},(o=o.ApiModule||(o.ApiModule={})).RealtimeProvider="r",o.BrowserStateTracker="b",o.PlacementManager="p",o.EventManager="e",o.APS="APS",o.DFP="DFP",o.SAS="SAS"},{}],27:[function(e,t,o){"use strict";Object.defineProperty(o,"__esModule",{value:!0}),o.SignalRProvider=void 0;var r=e("@microsoft/signalr");function n(){this.connectMaxRetries=2,this.connected=!1,this.mustReconnect=!1,this.connectAttempt=0}n.prototype.isConnected=function(){return this.connected},n.prototype.connect=function(t){var o=this;t&&(t.toLowerCase().startsWith("http://")||t.toLowerCase().startsWith("https://"))&&(this.client=(new r.HubConnectionBuilder).withUrl(t,{logger:r.LogLevel.None,skipNegotiation:!0,transport:r.HttpTransportType.WebSockets}).build(),this.client.onclose(function(e){o.log("Connection closed "+(e||"")),o.connected=!1,o.onDisconnect&&o.onDisconnect(),o.mustReconnect&&o.connect(t)}),this.client.on("ReceiveMessage",function(e){o.log(e),o.onReceiveMessage&&o.onReceiveMessage(e)}),this.mustReconnect=!0,this.log("Connecting..."),this.client.start().then(function(){o.log("Connected"),o.connected=!0,o.connectAttempt=0,o.onConnect&&o.onConnect()}).catch(function(e){o.log("Error on connect: "+e),o.connectAttempt<o.connectMaxRetries?setTimeout(function(){return o.connect(t)},2e3):o.onFailedConnect&&o.onFailedConnect(),o.connectAttempt++}))},n.prototype.disconnect=function(){var t=this;this.client&&(this.mustReconnect=!1,this.client.stop().then(function(){t.log("Disconnected...")}).catch(function(e){t.log("Error on disconnect: "+e)}))},n.prototype.send=function(e){var r=this;return this.log("Sent: "+e),new Promise(function(t,o){try{r.client.send("SendMessage",e).then(function(e){return t()}).catch(function(e){return o(e)})}catch(e){o(e.message)}})},n.prototype.log=function(e){this.onLogMessage&&this.onLogMessage(e)},o.SignalRProvider=n},{"@microsoft/signalr":24}],28:[function(e,t,o){"use strict";Object.defineProperty(o,"__esModule",{value:!0});var r=e("./modules/API"),n=e("./modules/realtime-messaging/SignalRProvider");function s(){(0,r.extend)(r.ApiModule.RealtimeProvider,this)}s.prototype.createInstance=function(){return new n.SignalRProvider},new s},{"./modules/API":26,"./modules/realtime-messaging/SignalRProvider":27}]},{},[28]);